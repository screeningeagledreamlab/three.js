<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - Occlusion Queries</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #fff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;

			background-color: #000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			padding: 10px;
			width: 100%;
			text-align: center;
			color: #fff;
		}

		a { color: blue; }

		#query-result, #shadow-query-result {
			position: absolute;
			margin: 0 auto;
			font-size: 24px;
			left: 0;
			right: 0;
		}
		#query-result {
			top: 100px;
		}
		#shadow-query-result {
			top: 130px;
		}

	</style>
</head>
<body>
<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Occlusion Queries<br />
	<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLQuery" target="_blank" rel="noopener">More info on WebGL2 Queries</a>
</div>
<div id='query-result'></div>
<div id='shadow-query-result'></div>
<div id='container'></div>

<script src="../build/three.js"></script>

<script src="js/controls/OrbitControls.js"></script>

<script src="js/WebGL.js"></script>

<script>

	/*global THREE, WEBGL, window */

	if ( WEBGL.isWebGL2Available() === false ) {

		document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
		document.querySelector('#info').style.display = 'none';
		throw new Error('no webgl2');

	}

	var clock = new THREE.Clock();

	var camera, scene, renderer;
	var cameraControls;
	var ambientLight, light;

	var sphere;

	var container = document.querySelector('#container'),
		queryResult = document.querySelector('#query-result'),
		shadowQueryResult = document.querySelector('#shadow-query-result');

	init();
	animate();

	function init() {

		var canvasWidth = window.innerWidth;
		var canvasHeight = window.innerHeight;

		// SCENE
		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xAAAAAA );

		// CAMERA
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 400 );
		camera.position.set( 0, 8, 20 );

		// LIGHTS
		ambientLight = new THREE.AmbientLight( 0x333333 );
		scene.add( ambientLight );

		light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
		scene.add( light );
		light.position.x = 2;
		light.position.y = 7;
		light.position.z = 10;
		light.castShadow = true;
		light.shadow.bias = -0.001;
		light.shadow.mapSize.width = 1024;
		light.shadow.mapSize.height = 1024;
		light.shadow.camera.top = 10;
		light.shadow.camera.bottom = -10;
		light.shadow.camera.left = 10;
		light.shadow.camera.right = -10;

		// RENDERER
		var canvas = document.createElement( 'canvas' );
		var context = canvas.getContext( 'webgl2' );
		renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
		renderer.shadowMap.enabled = true;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( canvasWidth, canvasHeight );
		container.appendChild( renderer.domElement );

		// EVENTS
		window.addEventListener( 'resize', onWindowResize, false );

		// CONTROLS
		cameraControls = new THREE.OrbitControls( camera, renderer.domElement );

		// STATICS
		var ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 100, 100, 10, 10 ), new THREE.MeshStandardMaterial( { color: 0x22CC66, side: THREE.DoubleSide } ) );
		scene.add( ground );
		ground.receiveShadow = true;
		ground.position.set( 0, -5, 0 );
		ground.rotation.x = -Math.PI / 2;

		var mat = new THREE.MeshStandardMaterial( { color: 0x6666AA } );
		var leftBox = new THREE.Mesh( new THREE.TorusKnotBufferGeometry( 2, 0.8, 128, 16 ), mat );
		scene.add( leftBox );
		leftBox.receiveShadow = true;
		leftBox.castShadow = true;
		leftBox.position.set( -5, 0, -3 );

		var rightBox = new THREE.Mesh( new THREE.BoxBufferGeometry( 5, 9, 1 ), mat );
		scene.add( rightBox );
		rightBox.receiveShadow = true;
		rightBox.castShadow = true;
		rightBox.position.set( 5, 0, 3 );

		sphere = new THREE.OcclusionQueryMesh( new THREE.SphereBufferGeometry( 1, 15, 15 ), new THREE.MeshStandardMaterial( {
			color: 0xFF4411,
			// disabling colorWrite should not break the occlusion testing
			colorWrite: true
		} ) );
		scene.add( sphere );
		sphere.frustumCulled = false;
		sphere.receiveShadow = true;
		sphere.castShadow = true;
		sphere.renderOrder = 999
		var highestFrame = -1;
		var shadowHighestFrame = -1;
		sphere.occlusionQueryCallback = function ( result, frame, queryCamera ) {

			var text;
			if ( queryCamera === camera && frame > highestFrame ) {

				highestFrame = frame;
				var text = result ? 'Sphere visible onscreen' : 'Sphere occluded onscreen';
				if ( queryResult.innerText !== text ) { queryResult.innerText = text; }

			}
			if ( queryCamera === light.shadow.camera && frame > shadowHighestFrame ) {

				shadowHighestFrame = frame;
				text = result ? 'Sphere visible in shadowmap' : 'Sphere occluded in shadowmap';
				if ( shadowQueryResult.innerText !== text ) { shadowQueryResult.innerText = text; }

			}

		};

		// var helper = new THREE.CameraHelper( light.shadow.camera );
		// scene.add( helper );

	}


	function onWindowResize() {

		var canvasWidth = window.innerWidth;
		var canvasHeight = window.innerHeight;

		renderer.setSize( canvasWidth, canvasHeight );

		camera.aspect = canvasWidth / canvasHeight;
		camera.updateProjectionMatrix();

		render();

	}

	function animate() {

		requestAnimationFrame( animate );

		var t = clock.getElapsedTime();

		sphere.position.x = Math.sin( t ) * 5;

		render();

	}

	function render() {

		renderer.render( scene, camera );

	}

</script>

</body>
</html>
